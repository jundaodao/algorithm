package 链表;

/**
 * 两个单链表相交的一些列问题：
 * 题目：
 * 给定两个可能有环，也可能无环的链表，头结点分别是 head1和 head2;
 * 实现一个函数，如果两个链表相交，请返回相交的第一个结点，如果不相交，返回 null
 */

/**
 * 思路一：空间复杂度 O(1)：
 * 相交的含义首先要搞明白：就是共用结点的意思。也就是内存地址一样。
 * 分别计算两个链表的第一个相交节点
 * -- 如果 node1 相交节点 =null ，node2 相交节点=null : 说明是两个链表都没有环
 *   1) node1的最后一个节点和 node2 的最后一个节点内存地址不同，说明肯定没有相交
 *   2）node1的最后一个节点和 node2 的最后一个节点内存地址相同，说明肯定相交
 *      -- 记录 node1、node2 长度分别 l1 和 l2。
 *      假如 l1 长，node1先走（l1-l2）的长度，之后 node1和 node2 同时前进，再次相遇的节点就是首次相交节点
*  -- 如果 node1或 node2 有其中一个有环
 *  结论：不可能有相交节点。因为是单链表，自己画图看一下，不可能有相交的情况。
 *  -- 如果 node1和 node2都有环，入环第一个节点分别是loop1 和 loop2
 *   1）两个链表各自成环 -- 不想交
 *      loop1转一圈，如果没有遇到 loop2,说明就是 2 个独立的环
 *   2）两个链表共用一部分，入环节点不同 -- 相交
 *  *   loop1转一圈，如果遇到 loop2说明就是这种情况，loop1或loop2 就是他的第一个相交节点
 *   3) 两个链表共用一部分，有相同的入环节点  -- 相交
 *      loop1==loop2 就是这种情况，把链表看成从头结点到 loop1 的长度，然后两个差值后，相遇的第一个节点就是第一个相交节点
 * */

/**
 * 思路二：
 * 还有一个非常简单的思路：map中
 * 先把 node1 的所有结点放入 map，然后遍历 node2，只要遇到在在 map中的，就是第一个相遇节点；否则就不相遇。
 * 缺点：空间复杂度 O(N)
 *
 * 优先解法一吧~
 *
 * */
public class b7链表相交 {

}
